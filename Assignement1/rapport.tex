\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french] {babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{url}
\usepackage[a4paper]{geometry}
\geometry{hscale=0.7,vscale=0.7,centering}
\usepackage{vmargin}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{moreverb}
\usepackage{listings}
\newtheorem{theorem}{Théorème}[section]
\newtheorem{defi}{Définition}[section] 
\newtheorem{prop}{Propriété}[section] 
\usepackage{color}
\definecolor{gris}{rgb}{0.95,0.95,0.95}
\lstset{numbers=left, tabsize=4, backgroundcolor=\color{gris},
frame=single, breaklines=true,
keywordstyle=\color{black},
stringstyle=\ttfamily,
framexleftmargin=6mm, xleftmargin=6mm}
%opening
\title{LINGI 2261 : Artificial Intelligence \\
Assignement 1}
\author{Cappart Quentin} 
\date{Année académique 2011-2012}

\begin{document}

	\section{Python AIMA}
	
	\subsection{In order to perform a search, what are the classes that you must define or extend ? What are they used for ?}
	We have to create a subclass to the class "Problem" given in the AIMA library. This subclass must implement the method successor, and possibly $ \_\_init\_\_$, $goal\_test$, and $path\_cost$. When this is done, we can use the search method on an instance of this subclass.
	\subsection{In graph\_search and tree\_search, what is the effect of the instruction fringe.extend(node.expand(problem)). What are the classes and methods involved ?}
	
	The method extend is used on a FIFOQueue to add elements at the end of this queue. These elements are the elements returned successively through the yield by node.expand(problem). \\
	The role of the expand method defined in the class Node is in term to reach all the children nodes accessible from one particular node. \\
	The classes involved are FIFOQueue and more precisely the method extend, the class Node to access the method expand and a Problem's subclass.
	
	\subsection{Both breadth\_first\_graph and depth\_first\_search are making a call to the same function. How s their fundamental difference implemented}
	
	The differences lies in the way that fringe is constructed. If we have a FIFOQueue, then the new elements are put in the end of the list, which involve a breadth first traversal. At the opposite, if we have a stack, the traversal will be depth first search because tree\_search fill the stack with children nodes to the current. Thus pop call return the child, until the depth one.
	
	\subsection{How is the closed list implemented in graph\_search? What is it used for? What
is the technical difference with the fringe? Why are those two specific structures
used?}
	
	The closest list contains True or False (nothing is False) associated with keys which are the node's state. It's used to keep a trace of which node are already explored. The technical difference with fringe is that fringe contains node which are already been explored or unexplored and the closed list is a Dictionary that contains True value for nodes that already been explored. \\ A specific structure is used for fringe to allow breadth first graph search or a depth first graph search. And closed is a Dictionary which map each node to a boolean value in order to know if they are explored or not.
	
	\subsection{How technically are the elements in the closed list searched? What are themethods involved? What properties must its elements have?}
	
	They are searched by the instruction "if node.state not in closed" which is the same that "if node.state not in closed.keys()" which search with an iterator among the keys if node.state isn't among them. Implicitly, we think that the  methods involved are the method \_\_iter\_\_() and the method keys(). They are handle by Python.\\
	The properties of the elements are couples of key->value.
	
	\subsection{How technically can you use the implementation of the closed list to deal with symmetrical states ? (hint: if two symmetrical states are considered to be the same, they will not be visited twice)}
	
	
	
\section{The Sliding Puzzle Problem}

	\subsection{Explain the advantages and weaknesses of each search strategy on this problem (depth first, breadth first, depth limited, iterative deepening, uniform cost). Which one would you choose to solve this problem?}
	
	\begin{itemize}
		\item \textbf{depth first} The main advantage of using a depth first search is its space complexity which is better than other because the algorithm is such as only one path must be in memory at a given time. 
		Though, if the tree is infinite, the path also becomes infinite and thus, it is possible to never find the goal and a major part of the tree is unexplored.
		\item \textbf{breadth first} While using this approach, we ensure that we will find the shallowest goal in our tree (which is the one that requires the less actions) but at the cost that all the different states generated during the execution are kept in memory which leads to an exponential time complexity.
		\item \textbf{depth limited} This one acts like the depth first algorithm, though it gets rid of the infinite path problem by setting a maximum depth. It is then possible to explore all the tree up to a certain depth. 
		Sadly it only works well when we have a good idea of the depth of the goal or at least an upper bound.
		\item \textbf{iterative deepening} The strategy of this one is to perform a search on each level one after the previous one using the depth first method, which is following one path at the time. It keeps the advantages of the depth limited way without the disadvantage that we don't know the depth of the goal.
		The inconvenient of using this method is that it generate slightly more node than the breadth first method.
		\item \textbf{uniform cost} It is a nice way to proceed when some actions are more costly than others. It is basically a breadth first search, although instead of a FIFO Queue, a priority queue is used.
		While convenient when costs are involved, this method is expensive in space as well as in time.\\
	\end{itemize}
	In order to solve the given problem, we'll choose the breadth first strategy over the other realistic which is the iterative deepening search because we're working on computer with enough memory so that we prefer to minimize the computation time.
	
	\subsection{Are there symmetrical (equivalent) states in this problem? What are the potential consequences on the search?}
	
	There may be many situations where symmetrical states occur. The consequences of this in the treatment of this problem	is that we may build several times the same tree and explore it as many times. It would constitute a useless usage of memory and a loss of time considering it generates and analyses the redundant states before reaching the goal state.
	
	\subsection{How are you dealing with those symmetrical states?}
	
	One way to deal with those symmetrical states is to keep track of the states already generated and analysed and to avoid to analyse its "twins". It is what performs the graph search compared to the tree search.
	
	\subsection{What are the advantages and disadvantages of using the tree and graph search for this problem. Which approach would you choose? Which approach allows you to avoid expending twice symmetrical states?}

	As said above, the graph search present an advantage in comparison to the tree search which is to consider same states only once (this statement is only true in the case of redundancy like in our case). But compared to the algorithms above (cfr q1), those searches do not present that much advantages, though they don't require particular data structures or recursive implementation. Their main disadvantages are either they use to much space, either they use to much time.
	The graph search is the one of the two that can avoid treating symmetrical states because it tests if the state has already been generated earlier.
	
\end{document}